#!/bin/bash

project_root=$(realpath $(dirname $0))

escaped_project_root=$(echo "$project_root" | sed 's/\//\\\//g')

print_remove_help() {
cat >&2 << EOF
Usage: ./foopak remove [OPTIONS...] MODULE
Remove module located in path 'foopak_modules/MODULE'

MODULE:		module to remove" >&2
		use './foopak list' to see all installed modules

OPTIONS:
	--help,-h	print this help message and exit
EOF
}

print_add_help() {
cat >&2 << EOF
Usage: ./foopak add [OPTIONS...] MODULE
Add module located in path MODULE from a git server to the project

MODULE:		path where the module resides in the git server. eg.:
		'rockerbacon/foopak-mock-module' adds the module from
		https://github.com/rockerbacon/foopak-mock-module

OPTIONS:
	--alias,-a	use different folder name for module
			default is MODULE with slashes
			replaced by underscores

	--tag,-t,	use specific tag or commit
	--commit,-c	default is the latest commit in the default remote

	--dir,-d	add module under different directory
			default is foopak_modules
			WARNING:
				modules outside 'foopak_modules'
				will not be scanned for commands

	--branch,-b	use specific branch
			default is the default remote branch

	--help,-h	print this help message and exit

EOF
}

locate_command() {
	if [ ! -d "$project_root/foopak_modules" ]; then
		return 0
	fi

	###    DEFAULTS    ###
	extra_tests=()
	output_mode="script"
	relative_path=true
	###    DEFAULTS    ###

	###    READ NAMED ARGS    ###
	reading_named_args=true
	while [ "$reading_named_args" == "true" ]; do
		option=$1
		case "$option" in
			--exclude-dir)
				extra_tests+=("-not -path '$project_root/$2/*'"); shift 2
			;;

			--absolute-path)
				relative_path=false; shift 1
			;;

			--print-module)
				output_mode="module"; shift 1
			;;

			--*|-*)
				echo "ERROR: unknown option '$option'" >&2
			;;

			*)
				reading_named_args=false
			;;
		esac
	done
	###    READ NAMED ARGS    ###

	###    READ POSITIONAL ARGS    ###
	command_name=$1; shift
	###    READ POSITIONAL ARGS    ###

	find_query=" \
					find '$project_root/foopak_modules' \
						${extra_tests[*]} \
						-path '*/foopak_meta/*' \
						-name command_list.conf \
		-exec	grep --with-filename -E '^$command_name\s' {} + \
	"
	command_location=$(bash -c "$find_query")

	if [ "$relative_path" == "true" ]; then
		command_location=$(echo "$command_location" | sed "s/$escaped_project_root\/foopak_modules\///")
	fi

	case "$output_mode" in
		script)
				echo "$command_location" \
			|	sed "s/foopak_meta\/command_list\.conf.*\s//"
		;;

		module)
				echo "$command_location" \
			|	sed "s/\/foopak_meta.*$//"
		;;
	esac
}

remove() {
	###    DEFAULTS    ###
	module_home_relative_dir="foopak_modules"
	###    DEFAULTS    ###

	###    READ NAMED ARGS    ###
	reading_named_args=true
	while [ "$reading_named_args" == "true" ]; do
		option=$1
		case "$option" in
			--dir|-d)
				module_home_relative_dir=$2; shift 2
			;;

			--help|-h)
				print_remove_help
				exit 0
			;;

			--*|-*)
				echo "ERROR: Unknown option '$option'" >&2
				echo >&2
				print_remove_help >&2
				exit 1
			;;

			*)
				reading_named_args=false
			;;
		esac
	done
	###    READ NAMED ARGS    ###

	###    READ POSITIONAL ARGS    ###
	module_alias=$1; shift

	if [ -z "$module_alias" ]; then
		echo "ERROR: please specify the module to remove" >&2
		echo >&2
		print_remove_help
		exit 1
	fi
	###    READ POSITIONAL ARGS    ###
	module_home_dir="$project_root/$module_home_relative_dir"

	module_relative_dir="$module_home_relative_dir/$module_alias"
	module_dir="$project_root/$module_relative_dir"

	if [ ! -d "$module_dir" ]; then
		echo "ERROR: module '$module_alias' not installed" >&2
		echo >&2
		print_remove_help
		exit 1
	fi

	git submodule deinit -f "$module_dir"
	git rm -f "$module_dir"
	rm -rf "$project_root/.git/modules/$module_relative_dir"
}

add() {
	###   DEFAULTS    ###
	git_server="https://github.com"
	module_home_relative_dir="foopak_modules"
	module_options=()
	###   DEFAULTS   ###

	###   READ NAMED ARGS    ###
	reading_named_args=true
	while [ "$reading_named_args" == "true" ]; do
		option=$1
		case "$option" in
			--alias|-a)
				module_alias=$2; shift 2
			;;

			--branch|-b)
				module_options+=("-b" "$2"); shift 2
			;;

			--commit|-c|--tag|-t)
				module_version=$2; shift 2
			;;

			--dir|-d)
				module_home_relative_dir=$2; shift 2
			;;

			--help|-h)
				print_add_help
				exit 0
			;;

			--*|-*)
				echo "ERROR: Unknown option '$option'" >&2
				echo >&2
				print_add_help >&2
				exit 1
			;;

			*)
				reading_named_args=false
			;;
		esac
	done
	###   READ NAMED ARGS    ###

	###   READ POSITIONAL ARGS    ###
	module_path=$1; shift
	if [ "$module_path" == "" ]; then
		echo "ERROR: please specify a module to add" >&2
		echo >&2
		print_add_help
		exit 1
	fi

	if [ -z "$module_alias" ]; then
		module_alias=$module_path
	fi
	###   READ POSITIONAL ARGS    ###

	module_home_dir="$project_root/$module_home_relative_dir"

	module_parent_dir=$(dirname "$module_alias")
	if [ "${module_parent_dir:0:1}" != "." ]; then
		mkdir -p "$project_root/$module_parent_dir"
	fi

	module_install_path="$module_home_relative_dir/$module_alias"

	if [ -e "$module_install_path" ]; then
		echo "ERROR: could not add module: directory '$module_install_path' already exists" >&2
		exit 1
	fi

	cd "$project_root"
	git submodule add ${module_options[@]} $git_server/$module_path "$module_install_path"

	if [ -n "$module_version" ]; then
		restore_workdir=$PWD
		cd "$project_root/$module_install_path"
			git checkout $module_version; exit_status=$?
		cd "$restore_workdir"
		if [ "$exit_status" != "0" ]; then
			echo "ERROR: could not checkout version '$module_version', rolling back" >&2
			remove "$module_alias"
			exit 1
		fi
	fi

	exec 3< "$module_install_path/foopak_meta/command_list.conf"
		command_list_version=$(read -u 3)

		while read -u 3 command || [ -n "$command" ]; do
			[ -z "$command" ] && continue
			[ "${command:0:1}" == "#" ] && continue

			command=$(echo "$command" | sed "s/\s.*$//")

			conflicting_module=$(locate_command --print-module --exclude-dir "$module_install_path" "$command")

			if [ -n "$conflicting_module" ]; then
				echo "ERROR: could not add module: command '$command' conflicts with module '$conflicting_module'" >&2
				remove "$module_alias"
				exit 1
			fi
		done
	exec 3>&-
}

exec_module_command() {
	command_name=$1; shift

	# TODO cache command
	command_script=$(locate_command --absolute-path "$command_name")

	if [ -z "$command_script" ]; then
		echo "ERROR: unknown command '$command_name'" >&2
		exit 1
	fi

	"$command_script" $@
}

command=$1; shift
case "$command" in
	remove|r)
		remove $@
	;;

	add|a)
		add $@
	;;

	locate-cmd)
		locate_command $@
	;;

	*)
		exec_module_command $command $@
	;;
esac

